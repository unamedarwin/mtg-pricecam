<!doctype html>
<html lang="ca">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MTG PriceCam — marcs alineats + touch fix</title>
<style>
  :root{font-family:system-ui,Arial,sans-serif; --pad:12px;}
  body{margin:var(--pad); background:#fff;}
  h1{font-size:1.08rem;margin:0 0 8px}

  /* Layout responsive: 1 columna en mòbil */
  .wrap{display:grid;grid-template-columns:1fr 420px;gap:12px;align-items:start}
  @media (max-width: 900px){ .wrap{grid-template-columns:1fr} }

  /* Stage (vídeo) */
  .stage{position:relative;border-radius:12px;overflow:hidden;background:#000; aspect-ratio:4/3;}
  video{width:100%;height:100%;display:block;object-fit:contain;background:#000}
  /* Overlay: per defecte no rep events; en edició sí */
  canvas.overlay{position:absolute;inset:0;pointer-events:none}
  canvas.overlay.interactive{pointer-events:auto; touch-action:none; } /* permet drag sense scroll */

  /* Panells */
  .panel{border:1px solid #e6e6e6;border-radius:10px;padding:10px;background:#fafafa}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{padding:10px 12px;border:1px solid #888;border-radius:10px;background:#fff;cursor:pointer}
  .pill{padding:.35rem .65rem;border:1px solid #bbb;border-radius:999px;background:#fff}
  #status{min-height:22px;color:#444}
  .big{font-size:1.35rem}
  .item{border-top:1px dashed #ddd;padding:8px 0}
  code{background:#f4f4f4;padding:.1rem .25rem;border-radius:4px}
  .muted{color:#777}

  /* Debug plegable per no “xafar” en mòbil */
  details.debug{margin-top:8px}
  details.debug summary{cursor:pointer; padding:8px 10px; background:#f2f2f2; border-radius:8px;}
  .kvs{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
  .kv{border:1px solid #eee;border-radius:8px;padding:6px;background:#fff}
  .mini{width:100%;aspect-ratio:3/1;border:1px dashed #ddd;border-radius:6px;display:block;background:#f8f8f8}

  .right{display:grid;gap:8px}
</style>
</head>
<body>
<h1>Escàner MTG (overlay alineat + edició ROIs sense interferències)</h1>

<div class="wrap">
  <!-- ESQUERRA -->
  <div>
    <div class="stage" id="stage">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="ovl" class="overlay"></canvas>
    </div>

    <div class="panel" style="margin-top:8px">
      <div class="row">
        <button id="start" class="btn">Inicia càmera</button>
        <button id="stop" class="btn">Atura</button>
        <label class="pill"><input id="pause" type="checkbox"> Pausa</label>
        <label class="pill"><input id="debug" type="checkbox"> Debug</label>
        <label class="pill"><input id="preferEs" type="checkbox" checked> Preferir ES</label>
        <label class="pill"><input id="useCv" type="checkbox"> Auto-ROI (OpenCV)</label>
      </div>
      <div class="row" style="margin-top:6px">
        <label>Freq. (s): <input id="interval" type="number" min="0.4" step="0.1" value="1.0" class="pill"></label>
        <label>Llindar €: <input id="threshold" type="number" step="0.5" value="15" class="pill"></label>
        <label><input id="beep" type="checkbox" checked> so</label>
        <label id="zoomWrap" style="display:none">Zoom: <input id="zoom" type="range" min="1" max="4" step="0.1"></label>
        <button id="flip" class="btn">Canvia càmera</button>
        <button id="editRoi" class="btn">Editar ROI: <span id="roiWhich">Codi</span></button>
      </div>
      <div id="status"></div>
      <div class="muted" style="margin-top:6px">HTTPS o <code>localhost</code>. Tap al vídeo = pausa (només si no estàs editant). Debug es fa amb el botó.</div>
    </div>

    <details class="debug" id="dbgDetails">
      <summary>ROI i text OCR (debug)</summary>
      <div class="kvs">
        <div class="kv">
          <div class="muted">ROI codi</div>
          <canvas id="miniCode" class="mini"></canvas>
          <div id="rawCode" class="muted" style="margin-top:4px"></div>
        </div>
        <div class="kv">
          <div class="muted">ROI set/idioma</div>
          <canvas id="miniSet" class="mini"></canvas>
          <div id="rawSet" class="muted" style="margin-top:4px"></div>
        </div>
      </div>
    </details>
  </div>

  <!-- DRETA -->
  <div class="right">
    <div class="panel">
      <div><b>Codi detectat:</b> <span id="lastCode">—</span></div>
      <div><b>Set/Idioma:</b> <span id="lastSet">—</span></div>
      <div style="margin-top:6px"><b>Preu:</b> <span id="lastPrice" class="big">—</span></div>
      <div id="explain" class="muted" style="margin-top:6px"></div>
    </div>
    <div class="panel">
      <div><b>Historial</b></div>
      <div id="list"></div>
    </div>
  </div>
</div>

<!-- OpenCV (opcional) -->
<script defer src="https://docs.opencv.org/4.x/opencv.js" onload="window.cvReady=true;"></script>
<!-- Tesseract 2.x + fallback sense worker -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
<script>
/* ====== refs ====== */
const video = document.getElementById('video');
const stage = document.getElementById('stage');
const ovl = document.getElementById('ovl'); const octx = ovl.getContext('2d');
const startBtn = document.getElementById('start'), stopBtn = document.getElementById('stop'), flipBtn = document.getElementById('flip');
const pauseChk = document.getElementById('pause'), debugChk = document.getElementById('debug'), preferEs = document.getElementById('preferEs'), useCvChk = document.getElementById('useCv');
const intervalIn = document.getElementById('interval'), thresholdIn = document.getElementById('threshold'), beepChk = document.getElementById('beep');
const zoomWrap = document.getElementById('zoomWrap'), zoomInput = document.getElementById('zoom');
const editRoiBtn = document.getElementById('editRoi'), roiWhich = document.getElementById('roiWhich');
const statusEl = document.getElementById('status'), listEl = document.getElementById('list');
const miniCode = document.getElementById('miniCode'), mctxC = miniCode.getContext('2d');
const miniSet  = document.getElementById('miniSet'),  mctxS = miniSet.getContext('2d');
const rawCodeEl = document.getElementById('rawCode'), rawSetEl = document.getElementById('rawSet');
const lastCode = document.getElementById('lastCode'), lastSet = document.getElementById('lastSet'), lastPrice = document.getElementById('lastPrice'), explain = document.getElementById('explain');

/* ====== estat ====== */
let stream=null, track=null, running=false, facing='environment';
let paused=false, scanning=false, timer=null, debug=false;
let cooldownUntil=0, buffer=[], seenKeys=new Set();
let useWorker=false, worker=null, workerReady=false;
let editing=false, editTarget='code';
let pinchRefDist=null;

/* canvasses offscreen */
const frame=document.createElement('canvas'); const fctx=frame.getContext('2d',{willReadFrequently:true});
const roiC=document.createElement('canvas'); const rctx=roiC.getContext('2d',{willReadFrequently:true});
const work=document.createElement('canvas'); const wctx=work.getContext('2d',{willReadFrequently:true});

/* ROIs en percentatge de l’àrea visible del vídeo (no del contenidor) */
const ROI={ code:{x:.03,y:.84,w:.44,h:.12}, set:{x:.35,y:.91,w:.30,h:.06} };

/* ====== utilitats ====== */
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
function status(msg){ statusEl.textContent = msg || ''; }
function secureOk(){ return location.protocol==='https:' || location.hostname==='localhost' || location.hostname==='127.0.0.1'; }
function normDigits(s){ return (s||'').replace(/[Oo]/g,'0').replace(/[IÍìíl]/gi,'1').replace(/S/g,'5').replace(/B/g,'8').replace(/[—–]/g,'-').replace(/·/g,'.').trim(); }

/* Rectangle real del vídeo dins el contenidor (per object-fit: contain) */
function getDisplayedVideoRect(){
  const r = stage.getBoundingClientRect();
  const boxW = r.width, boxH = r.height;
  const vw = video.videoWidth || 4, vh = video.videoHeight || 3;
  const videoAR = vw / vh, boxAR = boxW / boxH;
  let w, h, x, y;
  if (videoAR > boxAR) { // barres a dalt/baix
    w = boxW; h = boxW / videoAR; x = 0; y = (boxH - h) / 2;
  } else { // barres als costats
    h = boxH; w = boxH * videoAR; x = (boxW - w) / 2; y = 0;
  }
  return {x,y,w,h, boxW, boxH};
}

/* Dibuixa overlay exactament sobre l'àrea visible */
function drawOverlay(step){
  const dpr = window.devicePixelRatio || 1;
  const rect = stage.getBoundingClientRect();
  ovl.style.width = rect.width + 'px';
  ovl.style.height = rect.height + 'px';
  ovl.width  = Math.round(rect.width * dpr);
  ovl.height = Math.round(rect.height * dpr);
  octx.setTransform(dpr,0,0,dpr,0,0);
  octx.clearRect(0,0,rect.width,rect.height);

  const vis = getDisplayedVideoRect(); // {x,y,w,h}
  const toAbs = r => ({ x: vis.x + r.x*vis.w, y: vis.y + r.y*vis.h, w: r.w*vis.w, h: r.h*vis.h });

  const rects = [
    { ...toAbs(ROI.set),  color:'rgba(80,150,255,.9)', label:'SET•LANG' },
    { ...toAbs(ROI.code), color:'rgba(60,220,120,.9)', label:'CODI' }
  ];
  octx.lineWidth = 3;
  rects.forEach(rr=>{
    octx.strokeStyle = rr.color; octx.strokeRect(rr.x, rr.y, rr.w, rr.h);
    octx.fillStyle = rr.color; octx.fillRect(rr.x, rr.y-18, 90, 18);
    octx.fillStyle = '#000'; octx.font = '12px system-ui'; octx.fillText(rr.label, rr.x+6, rr.y-5);
  });
  if(step){
    octx.fillStyle='rgba(0,0,0,.45)'; octx.fillRect(vis.x, vis.y, 160, 22);
    octx.fillStyle='#fff'; octx.font='12px system-ui'; octx.fillText(step, vis.x+6, vis.y+15);
  }
}

/* ====== CÀMERA ====== */
function gum(constraints){
  if(navigator.mediaDevices?.getUserMedia) return navigator.mediaDevices.getUserMedia(constraints);
  const legacy=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia;
  return new Promise((res,rej)=> legacy ? legacy.call(navigator,constraints,res,rej) : rej(new Error('getUserMedia no suportat')));
}
async function startCam(){
  if(!secureOk()){ status('⚠️ Cal HTTPS o localhost per fer servir la càmera.'); return; }
  try{
    stream = await gum({ video:{facingMode:facing, width:{ideal:1280}, height:{ideal:960}, aspectRatio:{ideal:4/3}}, audio:false });
  }catch(e){ status('No s’ha pogut obrir la càmera: '+e.name+' — '+e.message); return; }

  video.srcObject = stream;
  video.muted = true; video.setAttribute('playsinline',''); video.setAttribute('autoplay','');
  try{ await video.play(); }catch(e){}
  video.onloadedmetadata = ()=>{ stage.style.aspectRatio = (video.videoWidth/video.videoHeight) + ' / 1'; drawOverlay(); };

  track = stream.getVideoTracks()[0];
  const caps=track.getCapabilities?.(); if(caps?.zoom){ zoomWrap.style.display=''; zoomInput.min=caps.zoom.min; zoomInput.max=caps.zoom.max; zoomInput.step=0.1; zoomInput.value=caps.zoom.min||1; } else zoomWrap.style.display='none';

  running=true; paused=false; status('Càmera en marxa.'); if(!workerReady) setupOCR(); tick();
}
function stopCam(){ running=false; if(timer) clearTimeout(timer); if(stream){ stream.getTracks().forEach(t=>t.stop()); } stream=null; track=null; status('Aturat.'); }

/* ====== OCR (worker si hi és, fallback sinó) ====== */
async function setupOCR(){
  try{
    if(Tesseract?.createWorker){
      const w=Tesseract.createWorker({logger:()=>{}});
      if(typeof w.load==='function'){
        await w.load(); await w.loadLanguage('eng'); await w.initialize('eng'); await w.setParameters({tessedit_pageseg_mode:7});
        worker=w; useWorker=true; workerReady=true; status('OCR llest (worker).'); return;
      }
    }
    workerReady=true; useWorker=false; status('OCR llest (mode simple).');
  }catch(e){ workerReady=true; useWorker=false; status('OCR en mode simple. '+e.message); }
}

/* ====== OCR helpers ====== */
function rotateRect(r,deg){ if(deg%180===0) return r; return {x:1-(r.y+r.h), y:r.x, w:r.h, h:r.w}; }
async function ocrRect(sourceCanvas, rect, deg, whitelist, outCanvas){
  const vw=sourceCanvas.width, vh=sourceCanvas.height;
  let r=rect; if(deg===90) r=rotateRect(rect,90); if(deg===180) r={x:1-(rect.x+rect.w), y:1-(rect.y+rect.h), w:rect.w, h:rect.h}; if(deg===270) r=rotateRect(rotateRect(rect,90),90);
  const sx=(r.x*vw)|0, sy=(r.y*vh)|0, sw=Math.max(2,(r.w*vw)|0), sh=Math.max(2,(r.h*vh)|0);
  roiC.width=sw*2; roiC.height=sh*2; rctx.imageSmoothingEnabled=false;
  rctx.drawImage(sourceCanvas, sx,sy,sw,sh, 0,0,roiC.width,roiC.height);
  const im=rctx.getImageData(0,0,roiC.width,roiC.height), d=im.data;
  for(let i=0;i<d.length;i+=4){ let y=0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2]; y=(y-128)*1.8+128; const v=y<140?0:255; d[i]=d[i+1]=d[i+2]=v; d[i+3]=255; }
  rctx.putImageData(im,0,0);
  if(outCanvas){ outCanvas.width=roiC.width; outCanvas.height=roiC.height; outCanvas.getContext('2d').drawImage(roiC,0,0); }
  if(useWorker){ await worker.setParameters({tessedit_char_whitelist:whitelist}); const {data}=await worker.recognize(roiC); return normDigits(data.text); }
  const {data}=await Tesseract.recognize(roiC,'eng',{tessedit_pageseg_mode:7,tessedit_char_whitelist:whitelist}); return normDigits(data.text);
}
async function readSet(src,ori){ const raw=await ocrRect(src,ROI.set,ori,'ABCDEFGHIJKLMNOPQRSTUVWXYZ•★* -',miniSet); rawSetEl.textContent=raw||'—'; const m=raw.match(/\b([A-Z]{2,5})\s*[•★\-\.\· ]\s*([A-Z]{2})\b/); if(!m) return null; return {set:m[1].toUpperCase(),lang:m[2].toUpperCase()}; }
async function readCode(src,ori){
  const raw=await ocrRect(src,ROI.code,ori,'0123456789/ CMURcmurSTabAB',miniCode); rawCodeEl.textContent=raw||'—';
  let m=raw.match(/(\d{1,4})\s*\/\s*(\d{2,4})\s*([A-Za-z])?/); if(m){ const num=String(+m[1]) + (/[a-z]$/i.test(m[1])?m[1].slice(-1).toLowerCase():''); const rarity=(m[3]||'').toUpperCase(); return {human:`${m[1]}/${m[2]} ${rarity||''}`.trim(), key:`A|${num}|${rarity}`, number:num, rarity}; }
  m=raw.match(/\b([RCUMST])\s*0*([0-9]{1,4}[a-z]?)\b/i); if(m){ const rarity=(m[1]||'').toUpperCase(); const num=m[2].toLowerCase(); return {human:`${rarity?rarity+' ':''}${num}`, key:`B|${num}|${rarity}`, number:num, rarity}; }
  return null;
}

/* ====== OpenCV (opcional) ====== */
function cvWarpToCard(){
  if(!window.cvReady || !cv || !video.videoWidth) return null;
  frame.width=video.videoWidth; frame.height=video.videoHeight; fctx.drawImage(video,0,0,frame.width,frame.height);
  const src=cv.imread(frame); let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray,gray,new cv.Size(5,5),0); let edges=new cv.Mat(); cv.Canny(gray,edges,50,150);
  let contours=new cv.MatVector(), hier=new cv.Mat(); cv.findContours(edges,contours,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
  let best=null, bestArea=0, tmp=new cv.Mat();
  for(let i=0;i<contours.size();i++){ const c=contours.get(i); const peri=cv.arcLength(c,true); cv.approxPolyDP(c,tmp,0.02*peri,true);
    if(tmp.total()===4){ const area=cv.contourArea(tmp); if(area>bestArea){bestArea=area; best=tmp.clone();} } c.delete();
  }
  if(!best){ src.delete(); gray.delete(); edges.delete(); contours.delete(); hier.delete(); tmp.delete(); return null; }
  let pts=[]; for(let i=0;i<4;i++){ pts.push({x:best.data32S[i*2], y:best.data32S[i*2+1]}); }
  pts.sort((a,b)=>a.y-b.y); const top=pts.slice(0,2).sort((a,b)=>a.x-b.x), bot=pts.slice(2).sort((a,b)=>a.x-b.x);
  const tl=top[0], tr=top[1], bl=bot[0], br=bot[1];
  const W=744, H=1040; const dst=cv.Mat.zeros(H,W,cv.CV_8UC4);
  const srcTri=cv.matFromArray(4,1,cv.CV_32FC2,[tl.x,tl.y, tr.x,tr.y, br.x,br.y, bl.x,bl.y]);
  const dstTri=cv.matFromArray(4,1,cv.CV_32FC2,[0,0, W,0, W,H, 0,H]);
  const M=cv.getPerspectiveTransform(srcTri,dstTri); cv.warpPerspective(src,dst,M,new cv.Size(W,H));
  src.delete(); gray.delete(); edges.delete(); contours.delete(); hier.delete(); tmp.delete(); best.delete(); srcTri.delete(); dstTri.delete(); M.delete();
  return dst;
}
function matToCanvas(mat){ const c=document.createElement('canvas'); c.width=mat.cols; c.height=mat.rows; cv.imshow(c,mat); return c; }

/* ====== LOOP ====== */
function schedule(){ if(!running) return; const ms=Math.max(250, Number(intervalIn.value)*1000); timer=setTimeout(tick, ms); }
async function tick(){
  if(!running || paused || scanning) { schedule(); return; }
  scanning=true;
  try{
    // Font per OCR: warp (si OpenCV + activat), sinó frame cru
    let srcCanvas;
    if(useCvChk.checked && window.cvReady){ const warped=cvWarpToCard(); if(warped){ srcCanvas=matToCanvas(warped); warped.delete(); drawOverlay('OpenCV (warp)'); } else { srcCanvas=grabFrame(); drawOverlay('heurística'); } }
    else { srcCanvas=grabFrame(); drawOverlay(debug?'escanejant':''); }

    const oris = (srcCanvas===frame) ? [0,180,90,270] : [0];
    let foundSet=null, bestOri=0;
    for(const o of oris){ const s=await readSet(srcCanvas,o); if(s){ foundSet=s; bestOri=o; break; } }
    const code=await readCode(srcCanvas,bestOri);
    if(foundSet) lastSet.textContent=`${foundSet.set} • ${foundSet.lang}`;
    if(!code){ status('Sense codi…'); scanning=false; schedule(); return; }

    // validació doble
    const now=performance.now(); buffer.push({code,t:now}); if(buffer.length>2) buffer.shift();
    const ok = buffer.length===2 && buffer[0].code.key===buffer[1].code.key && (buffer[1].t-buffer[0].t)<1500;
    if(!ok){ status('Detectat (confirmant)…'); scanning=false; schedule(); return; }

    if(seenKeys.has(code.key) && now<cooldownUntil){ scanning=false; schedule(); return; }
    cooldownUntil=now+2000; seenKeys.add(code.key);

    lastCode.textContent=code.human;
    const res=await lookupPrice({code, setInfo:foundSet, preferEs:preferEs.checked});
    renderPrice(res);
  }catch(e){ console.error(e); status('Error: '+e.message); }
  finally{ scanning=false; schedule(); }
}
function grabFrame(){ frame.width=video.videoWidth; frame.height=video.videoHeight; fctx.drawImage(video,0,0,frame.width,frame.height); return frame; }

/* ====== Scryfall ====== */
async function fetchBySetAndNumber(set, number, lang){
  try{ const langPart=(lang && lang.toLowerCase()==='sp')?'/es':''; const url=`https://api.scryfall.com/cards/${set.toLowerCase()}/${encodeURIComponent(number)}${langPart}`;
       const r=await fetch(url); if(r.ok){ const j=await r.json(); return [j]; } }catch(e){}
  return [];
}
async function scry(url){ try{ const r=await fetch(url); const j=await r.json(); return j.data||[]; }catch(e){ return []; } }
async function lookupPrice({code, setInfo, preferEs}){
  let data=[]; if(setInfo?.set) data=await fetchBySetAndNumber(setInfo.set, code.number, setInfo.lang);
  if(!data.length){
    let q=`number:${code.number}`+(setInfo?.set?` set:${setInfo.set.toLowerCase()}`:'')+(preferEs?' lang:es':'')+(code.rarity?` rarity:${code.rarity.toLowerCase()}`:'');
    const url=`https://api.scryfall.com/cards/search?q=${encodeURIComponent(q)}&unique=prints&include_extras=false&order=eur&dir=desc`;
    data=await scry(url);
  }
  if(!data.length) return {ok:false, why:'Sense resultats.'};
  const items=data.map(c=>{ const p=c.prices||{}; const eur=+(p.eur||p.eur_foil||0); const usd=+(p.usd||p.usd_foil||p.usd_etched||0); return {card:c,eur,usd,best:(eur||usd||0)}; }).sort((a,b)=>b.best-a.best);
  const b=items[0];
  return { ok:true, name:b.card.name, set:b.card.set.toUpperCase(), lang:b.card.lang.toUpperCase(), number:b.card.collector_number, rarity:b.card.rarity, eur:b.eur||null, usd:b.usd||null, link:b.card.scryfall_uri||b.card.uri };
}

/* ====== UI ====== */
function renderPrice(res){
  if(!res.ok){ lastPrice.textContent='—'; explain.textContent=res.why||'—'; return; }
  lastSet.textContent=`${res.set} • ${res.lang}`;
  lastPrice.innerHTML=`${res.eur?res.eur.toFixed(2)+' €':'—'} <span class="muted">(USD ${res.usd?res.usd.toFixed(2):'—'})</span>`;
  explain.innerHTML=`${res.name} · #${res.number} · ${res.rarity} · <a href="${res.link}" target="_blank" rel="noopener">Scryfall</a>`;
  const row=document.createElement('div'); row.className='item';
  row.innerHTML=`<div><b>${res.name}</b> (${res.set}) · #${res.number} · ${res.lang}</div>
                 <div>Preu: <b>${res.eur?res.eur.toFixed(2)+' €':'—'}</b> <span class="muted">(USD ${res.usd?res.usd.toFixed(2):'—'})</span></div>`;
  listEl.prepend(row);
  const thr=Number(thresholdIn.value)||0; if((res.eur||res.usd||0)>=thr) beep();
}
function beep(){ if(!beepChk.checked) return; const ctx=new (window.AudioContext||window.webkitAudioContext)(); const o=ctx.createOscillator(); const g=ctx.createGain(); o.frequency.value=920; o.connect(g); g.connect(ctx.destination);
  g.gain.setValueAtTime(0.0001, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.45, ctx.currentTime+0.01); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.25); o.start(); o.stop(ctx.currentTime+0.26); }

/* ====== Controls ====== */
startBtn.onclick = async()=>{ await startCam(); };
stopBtn.onclick  = stopCam;
flipBtn.onclick  = async()=>{ facing=(facing==='environment'?'user':'environment'); stopCam(); await sleep(150); startCam(); };
pauseChk.onchange = e=>{ paused=e.target.checked; };
debugChk.onchange = e=>{ debug=e.target.checked; drawOverlay(debug?'debug':''); };
zoomInput.oninput = e=>{ const v=Number(e.target.value); if(track?.applyConstraints){ track.applyConstraints({advanced:[{zoom:v}]}); } };

/* Editar ROI (activa pointer-events a l’overlay i evita que el tap pausi) */
editRoiBtn.onclick = ()=>{
  editing=!editing;
  ovl.classList.toggle('interactive', editing);
  editTarget=(editTarget==='code'?'set':'code');
  roiWhich.textContent=(editTarget==='code'?'Codi':'Set');
};
/* drag sobre overlay: mou ROI seleccionat (coordenades relatives al vídeo visible) */
let drag=null;
ovl.addEventListener('touchstart', e=>{
  if(!editing) return;
  e.stopPropagation();
  const t=e.touches[0]; const r=stage.getBoundingClientRect();
  const vis=getDisplayedVideoRect();
  const x=(t.clientX - r.left - vis.x)/vis.w;
  const y=(t.clientY - r.top  - vis.y)/vis.h;
  drag={start:{x,y}, base:{...ROI[editTarget]}};
},{passive:true});
ovl.addEventListener('touchmove', e=>{
  if(!editing || !drag) return;
  e.stopPropagation(); e.preventDefault();
  const t=e.touches[0]; const r=stage.getBoundingClientRect();
  const vis=getDisplayedVideoRect();
  const x=(t.clientX - r.left - vis.x)/vis.w;
  const y=(t.clientY - r.top  - vis.y)/vis.h;
  const dx=x-drag.start.x, dy=y-drag.start.y;
  ROI[editTarget].x=Math.max(0,Math.min(1-ROI[editTarget].w, drag.base.x+dx));
  ROI[editTarget].y=Math.max(0,Math.min(1-ROI[editTarget].h, drag.base.y+dy));
  drawOverlay('editant ROI');
},{passive:false});
ovl.addEventListener('touchend', e=>{ if(!editing) return; e.stopPropagation(); drag=null; });

/* Tap per pausar: només quan NO estàs editant */
stage.addEventListener('click', ()=>{ if(!editing){ paused=!paused; pauseChk.checked=paused; } });

/* overlay sempre alineat */
new ResizeObserver(()=>drawOverlay()).observe(stage);

/* planificador + “frame grabber” */
function schedule(){ if(!running) return; const ms=Math.max(250, Number(intervalIn.value)*1000); timer=setTimeout(tick, ms); }
function grabFrame(){ frame.width=video.videoWidth; frame.height=video.videoHeight; fctx.drawImage(video,0,0,frame.width,frame.height); return frame; }
</script>
</body>
</html>
