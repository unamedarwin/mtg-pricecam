<!doctype html>
<html lang="ca">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MTG PriceCam ‚Äî iPhone friendly</title>
<style>
  :root{font-family:system-ui,Arial,sans-serif; --pad:12px;}
  body{margin:var(--pad); background:#fff;}
  h1{font-size:1.08rem;margin:0 0 8px}
  /* Layout responsive */
  .wrap{display:grid;grid-template-columns:1fr 420px;gap:12px;align-items:start}
  @media (max-width: 900px){
    .wrap{grid-template-columns:1fr}
  }
  /* Stage (v√≠deo) */
  .stage{position:relative;border-radius:12px;overflow:hidden;background:#000; 
         /* aspect ratio segur mentre no tenim metadata; despr√©s el fem din√†mic */
         aspect-ratio: 4 / 3;}
  video{width:100%;height:100%;display:block;object-fit:contain; background:#000;}
  canvas.overlay{position:absolute;inset:0;pointer-events:none}
  /* Panells */
  .panel{border:1px solid #e6e6e6;border-radius:10px;padding:10px;background:#fafafa}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{padding:10px 12px;border:1px solid #888;border-radius:10px;background:#fff;cursor:pointer}
  .pill{padding:.35rem .65rem;border:1px solid #bbb;border-radius:999px;background:#fff}
  #status{min-height:22px;color:#444}
  .big{font-size:1.35rem}
  .item{border-top:1px dashed #ddd;padding:8px 0}
  code{background:#f4f4f4;padding:.1rem .25rem;border-radius:4px}
  .muted{color:#777}
  /* Debug block plegable per a m√≤bil */
  details.debug{margin-top:8px}
  details.debug summary{cursor:pointer; padding:8px 10px; background:#f2f2f2; border-radius:8px;}
  .kvs{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
  .kv{border:1px solid #eee;border-radius:8px;padding:6px;background:#fff}
  .mini{width:100%;aspect-ratio:3/1;border:1px dashed #ddd;border-radius:6px;display:block;background:#f8f8f8}
  /* ‚ÄúColumna dreta‚Äù que ja no es xafa en m√≤bil */
  .right{display:grid;gap:8px}
</style>
</head>
<body>
<h1>Esc√†ner MTG (overlay + debug + m√≤bil OK)</h1>

<div class="wrap">
  <!-- ESQUERRA: V√≠deo + controls b√†sics -->
  <div>
    <div class="stage" id="stage">
      <!-- üëá Afegeixo autoplay playsinline muted perqu√® iOS el mostri i deixi fer play() -->
      <video id="video" autoplay playsinline muted></video>
      <canvas id="ovl" class="overlay"></canvas>
    </div>

    <div class="panel" style="margin-top:8px">
      <div class="row">
        <button id="start" class="btn">Inicia c√†mera</button>
        <button id="stop" class="btn">Atura</button>
        <label class="pill"><input id="pause" type="checkbox"> Pausa</label>
        <label class="pill"><input id="preferEs" type="checkbox" checked> Preferir ES</label>
        <label class="pill"><input id="useCv" type="checkbox"> Auto-ROI (OpenCV)</label>
      </div>
      <div class="row" style="margin-top:6px">
        <label>Freq. (s): <input id="interval" type="number" min="0.4" step="0.1" value="1.0" class="pill"></label>
        <label>Llindar ‚Ç¨: <input id="threshold" type="number" step="0.5" value="15" class="pill"></label>
        <label><input id="beep" type="checkbox" checked> so</label>
        <label id="zoomWrap" style="display:none">Zoom: <input id="zoom" type="range" min="1" max="4" step="0.1"></label>
        <button id="flip" class="btn">Canvia c√†mera</button>
        <button id="editRoi" class="btn">Editar ROI: <span id="roiWhich">Codi</span></button>
      </div>
      <div id="status"></div>
      <div class="muted" style="margin-top:6px">Serveix per <b>HTTPS</b> o <code>localhost</code>. Toca el v√≠deo per pausar; doble-tap: mostra overlay; pin√ßa: zoom.</div>
    </div>

    <!-- Debug plegable (no aixafa res en m√≤bil) -->
    <details class="debug" id="dbgDetails">
      <summary>ROI i text OCR (debug)</summary>
      <div class="kvs">
        <div class="kv">
          <div class="muted">ROI codi</div>
          <canvas id="miniCode" class="mini"></canvas>
          <div id="rawCode" class="muted" style="margin-top:4px"></div>
        </div>
        <div class="kv">
          <div class="muted">ROI set/idioma</div>
          <canvas id="miniSet" class="mini"></canvas>
          <div id="rawSet" class="muted" style="margin-top:4px"></div>
        </div>
      </div>
    </details>
  </div>

  <!-- DRETA: Resultats / Historial (en m√≤bil es posa sota, ample 100%) -->
  <div class="right">
    <div class="panel">
      <div><b>Codi detectat:</b> <span id="lastCode">‚Äî</span></div>
      <div><b>Set/Idioma:</b> <span id="lastSet">‚Äî</span></div>
      <div style="margin-top:6px"><b>Preu:</b> <span id="lastPrice" class="big">‚Äî</span></div>
      <div id="explain" class="muted" style="margin-top:6px"></div>
    </div>
    <div class="panel">
      <div><b>Historial</b></div>
      <div id="list"></div>
    </div>
  </div>
</div>

<!-- OpenCV (opcional) -->
<script defer src="https://docs.opencv.org/4.x/opencv.js" onload="window.cvReady=true;"></script>
<!-- Tesseract 2.x + fallback sense worker -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
<script>
/* ====== Refs ====== */
const video = document.getElementById('video');
const stage = document.getElementById('stage');
const ovl = document.getElementById('ovl'); const octx = ovl.getContext('2d');
const startBtn = document.getElementById('start'), stopBtn = document.getElementById('stop'), flipBtn = document.getElementById('flip');
const pauseChk = document.getElementById('pause'), preferEs = document.getElementById('preferEs'), useCvChk = document.getElementById('useCv');
const intervalIn = document.getElementById('interval'), thresholdIn = document.getElementById('threshold'), beepChk = document.getElementById('beep');
const zoomWrap = document.getElementById('zoomWrap'), zoomInput = document.getElementById('zoom');
const editRoiBtn = document.getElementById('editRoi'), roiWhich = document.getElementById('roiWhich');
const statusEl = document.getElementById('status'), listEl = document.getElementById('list');
const miniCode = document.getElementById('miniCode'), mctxC = miniCode.getContext('2d');
const miniSet  = document.getElementById('miniSet'),  mctxS = miniSet.getContext('2d');
const rawCodeEl = document.getElementById('rawCode'), rawSetEl = document.getElementById('rawSet');
const lastCode = document.getElementById('lastCode'), lastSet = document.getElementById('lastSet'), lastPrice = document.getElementById('lastPrice'), explain = document.getElementById('explain');
const dbgDetails = document.getElementById('dbgDetails');

/* ====== Estat ====== */
let stream=null, track=null, running=false, facing='environment';
let paused=false, scanning=false, timer=null;
let cooldownUntil=0, buffer=[], seenKeys=new Set();
let useWorker=false, worker=null, workerReady=false;
let pinchRefDist=null;

/* canvasses offscreen */
const frame=document.createElement('canvas'); const fctx=frame.getContext('2d',{willReadFrequently:true});
const roiC=document.createElement('canvas'); const rctx=roiC.getContext('2d',{willReadFrequently:true});

/* ROIs */
const ROI={ code:{x:.03,y:.84,w:.44,h:.12}, set:{x:.35,y:.91,w:.30,h:.06} };
let editing=false, editTarget='code';

/* Utils */
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
function status(msg){ statusEl.textContent = msg || ''; }
function secureOk(){ return location.protocol==='https:' || location.hostname==='localhost' || location.hostname==='127.0.0.1'; }
function normDigits(s){ return (s||'').replace(/[Oo]/g,'0').replace(/[I√ç√¨√≠l]/gi,'1').replace(/S/g,'5').replace(/B/g,'8').replace(/[‚Äî‚Äì]/g,'-').replace(/¬∑/g,'.').trim(); }
function drawOverlay(step){
  const r=stage.getBoundingClientRect(); ovl.width=r.width; ovl.height=r.height;
  const W=ovl.width,H=ovl.height; octx.clearRect(0,0,W,H);
  const rects=[ {...ROI.set,color:'rgba(80,150,255,.9)',label:'SET‚Ä¢LANG'}, {...ROI.code,color:'rgba(60,220,120,.9)',label:'CODI'} ];
  rects.forEach(rr=>{
    octx.strokeStyle=rr.color; octx.lineWidth=3; octx.strokeRect(rr.x*W,rr.y*H,rr.w*W,rr.h*H);
    octx.fillStyle=rr.color; octx.fillRect(rr.x*W, rr.y*H-18, 90, 18);
    octx.fillStyle='#000'; octx.font='12px system-ui'; octx.fillText(rr.label, rr.x*W+6, rr.y*H-5);
  });
  if(step){ octx.fillStyle='rgba(0,0,0,.45)'; octx.fillRect(0,0,200,22); octx.fillStyle='#fff'; octx.font='12px system-ui'; octx.fillText(step,6,15); }
}

/* ====== C√ÄMERA (amb fixes iOS) ====== */
function gum(constraints){
  if(navigator.mediaDevices?.getUserMedia) return navigator.mediaDevices.getUserMedia(constraints);
  const legacy=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia;
  return new Promise((res,rej)=> legacy ? legacy.call(navigator,constraints,res,rej) : rej(new Error('getUserMedia no suportat')));
}
async function startCam(){
  if(!secureOk()){ status('‚ö†Ô∏è Cal HTTPS o localhost per fer servir la c√†mera.'); return; }
  try{
    stream = await gum({ video:{facingMode:facing, width:{ideal:1280}, height:{ideal:960}, aspectRatio:{ideal:4/3}}, audio:false });
  }catch(e){ status('No s‚Äôha pogut obrir la c√†mera: '+e.name+' ‚Äî '+e.message); return; }

  video.srcObject = stream;
  video.muted = true; // iOS
  video.setAttribute('playsinline',''); video.setAttribute('autoplay',''); // iOS
  try { await video.play(); } catch(e) { /* alguns navegadors la comencen sols */ }

  // Ajusta l‚Äôaspect-ratio real del contenidor quan tenim metadata (evita v√≠deo invisible/zero height)
  video.onloadedmetadata = ()=>{
    // convertim el contenidor a la relaci√≥ real del stream
    const ar = (video.videoWidth && video.videoHeight) ? (video.videoWidth / video.videoHeight) : (4/3);
    stage.style.aspectRatio = `${ar} / 1`;
    drawOverlay();
  };

  track = stream.getVideoTracks()[0];
  const caps=track.getCapabilities?.(); if(caps?.zoom){ zoomWrap.style.display=''; zoomInput.min=caps.zoom.min; zoomInput.max=caps.zoom.max; zoomInput.step=0.1; zoomInput.value=caps.zoom.min||1; } else zoomWrap.style.display='none';

  running=true; paused=false; status('C√†mera en marxa.'); if(!workerReady) setupOCR(); tick();
}
function stopCam(){ running=false; if(timer) clearTimeout(timer); if(stream){ stream.getTracks().forEach(t=>t.stop()); } stream=null; track=null; status('Aturat.'); }

/* ====== OCR (worker si hi √©s, fallback sin√≥) ====== */
async function setupOCR(){
  try{
    if(Tesseract?.createWorker){
      const w=Tesseract.createWorker({logger:()=>{}});
      if(typeof w.load==='function'){
        await w.load(); await w.loadLanguage('eng'); await w.initialize('eng'); await w.setParameters({tessedit_pageseg_mode:7});
        worker=w; useWorker=true; workerReady=true; status('OCR llest (worker).'); return;
      }
    }
    workerReady=true; useWorker=false; status('OCR llest (mode simple).');
  }catch(e){ workerReady=true; useWorker=false; status('OCR en mode simple. '+e.message); }
}

/* ====== OCR helpers ====== */
const work=document.createElement('canvas'); const wctx=work.getContext('2d',{willReadFrequently:true});
function rotateRect(r,deg){ if(deg%180===0) return r; return {x:1-(r.y+r.h), y:r.x, w:r.h, h:r.w}; }
async function ocrRect(sourceCanvas, rect, deg, whitelist, outCanvas){
  const vw=sourceCanvas.width, vh=sourceCanvas.height;
  let r=rect; if(deg===90) r=rotateRect(rect,90); if(deg===180) r={x:1-(rect.x+rect.w), y:1-(rect.y+rect.h), w:rect.w, h:rect.h}; if(deg===270) r=rotateRect(rotateRect(rect,90),90);
  const sx=(r.x*vw)|0, sy=(r.y*vh)|0, sw=Math.max(2,(r.w*vw)|0), sh=Math.max(2,(r.h*vh)|0);
  roiC.width=sw*2; roiC.height=sh*2; rctx.imageSmoothingEnabled=false;
  rctx.drawImage(sourceCanvas, sx,sy,sw,sh, 0,0,roiC.width,roiC.height);
  const im=rctx.getImageData(0,0,roiC.width,roiC.height), d=im.data;
  for(let i=0;i<d.length;i+=4){ let y=0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2]; y=(y-128)*1.8+128; const v=y<140?0:255; d[i]=d[i+1]=d[i+2]=v; d[i+3]=255; }
  rctx.putImageData(im,0,0);
  if(outCanvas){ outCanvas.width=roiC.width; outCanvas.height=roiC.height; outCanvas.getContext('2d').drawImage(roiC,0,0); }
  if(useWorker){ await worker.setParameters({tessedit_char_whitelist:whitelist}); const {data}=await worker.recognize(roiC); return normDigits(data.text); }
  const {data}=await Tesseract.recognize(roiC,'eng',{tessedit_pageseg_mode:7,tessedit_char_whitelist:whitelist}); return normDigits(data.text);
}
async function readSet(src,ori){ const raw=await ocrRect(src,ROI.set,ori,'ABCDEFGHIJKLMNOPQRSTUVWXYZ‚Ä¢‚òÖ* -',miniSet); rawSetEl.textContent=raw||'‚Äî'; const m=raw.match(/\b([A-Z]{2,5})\s*[‚Ä¢‚òÖ\-\.\¬∑ ]\s*([A-Z]{2})\b/); if(!m) return null; return {set:m[1].toUpperCase(),lang:m[2].toUpperCase()}; }
async function readCode(src,ori){
  const raw=await ocrRect(src,ROI.code,ori,'0123456789/ CMURcmurSTabAB',miniCode); rawCodeEl.textContent=raw||'‚Äî';
  let m=raw.match(/(\d{1,4})\s*\/\s*(\d{2,4})\s*([A-Za-z])?/); if(m){ const num=String(+m[1]) + (/[a-z]$/i.test(m[1])?m[1].slice(-1).toLowerCase():''); const rarity=(m[3]||'').toUpperCase(); return {human:`${m[1]}/${m[2]} ${rarity||''}`.trim(), key:`A|${num}|${rarity}`, number:num, rarity}; }
  m=raw.match(/\b([RCUMST])\s*0*([0-9]{1,4}[a-z]?)\b/i); if(m){ const rarity=(m[1]||'').toUpperCase(); const num=m[2].toLowerCase(); return {human:`${rarity?rarity+' ':''}${num}`, key:`B|${num}|${rarity}`, number:num, rarity}; }
  return null;
}

/* ====== OpenCV (opcional) ====== */
function cvWarpToCard(){
  if(!window.cvReady || !cv || !video.videoWidth) return null;
  frame.width=video.videoWidth; frame.height=video.videoHeight; fctx.drawImage(video,0,0,frame.width,frame.height);
  const src=cv.imread(frame); let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray,gray,new cv.Size(5,5),0); let edges=new cv.Mat(); cv.Canny(gray,edges,50,150);
  let contours=new cv.MatVector(), hier=new cv.Mat(); cv.findContours(edges,contours,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
  let best=null, bestArea=0, tmp=new cv.Mat();
  for(let i=0;i<contours.size();i++){ const c=contours.get(i); const peri=cv.arcLength(c,true); cv.approxPolyDP(c,tmp,0.02*peri,true);
    if(tmp.total()===4){ const area=cv.contourArea(tmp); if(area>bestArea){bestArea=area; best=tmp.clone();} } c.delete();
  }
  if(!best){ src.delete(); gray.delete(); edges.delete(); contours.delete(); hier.delete(); tmp.delete(); return null; }
  let pts=[]; for(let i=0;i<4;i++){ pts.push({x:best.data32S[i*2], y:best.data32S[i*2+1]}); }
  pts.sort((a,b)=>a.y-b.y); const top=pts.slice(0,2).sort((a,b)=>a.x-b.x), bot=pts.slice(2).sort((a,b)=>a.x-b.x);
  const tl=top[0], tr=top[1], bl=bot[0], br=bot[1];
  const W=744, H=1040; const dst=cv.Mat.zeros(H,W,cv.CV_8UC4);
  const srcTri=cv.matFromArray(4,1,cv.CV_32FC2,[tl.x,tl.y, tr.x,tr.y, br.x,br.y, bl.x,bl.y]);
  const dstTri=cv.matFromArray(4,1,cv.CV_32FC2,[0,0, W,0, W,H, 0,H]);
  const M=cv.getPerspectiveTransform(srcTri,dstTri); cv.warpPerspective(src,dst,M,new cv.Size(W,H));
  src.delete(); gray.delete(); edges.delete(); contours.delete(); hier.delete(); tmp.delete(); best.delete(); srcTri.delete(); dstTri.delete(); M.delete();
  return dst;
}
function matToCanvas(mat){ const c=document.createElement('canvas'); c.width=mat.cols; c.height=mat.rows; cv.imshow(c,mat); return c; }

/* ====== Loop ====== */
function schedule(){ if(!running) return; const ms=Math.max(250, Number(intervalIn.value)*1000); timer=setTimeout(tick, ms); }
async function tick(){
  if(!running || paused || scanning) { schedule(); return; }
  scanning=true;
  try{
    // Font: warp (si OpenCV + activat), sin√≥ frame cru
    let srcCanvas;
    if(useCvChk.checked && window.cvReady){ const warped=cvWarpToCard(); if(warped){ srcCanvas=matToCanvas(warped); warped.delete(); drawOverlay('OpenCV (warp)'); } else { srcCanvas=grabFrame(); drawOverlay('heur√≠stica'); } }
    else { srcCanvas=grabFrame(); drawOverlay(); }

    const oris = (srcCanvas===frame) ? [0,180,90,270] : [0];
    let foundSet=null, bestOri=0;
    for(const o of oris){ const s=await readSet(srcCanvas,o); if(s){ foundSet=s; bestOri=o; break; } }
    const code=await readCode(srcCanvas,bestOri);
    if(foundSet) lastSet.textContent=`${foundSet.set} ‚Ä¢ ${foundSet.lang}`;
    if(!code){ status('Sense codi‚Ä¶'); scanning=false; schedule(); return; }

    // validaci√≥ doble
    const now=performance.now(); buffer.push({code,t:now}); if(buffer.length>2) buffer.shift();
    const ok = buffer.length===2 && buffer[0].code.key===buffer[1].code.key && (buffer[1].t-buffer[0].t)<1500;
    if(!ok){ status('Detectat (confirmant)‚Ä¶'); scanning=false; schedule(); return; }

    if(seenKeys.has(code.key) && now<cooldownUntil){ scanning=false; schedule(); return; }
    cooldownUntil=now+2000; seenKeys.add(code.key);

    lastCode.textContent=code.human;
    const res=await lookupPrice({code, setInfo:foundSet, preferEs:preferEs.checked});
    renderPrice(res);
  }catch(e){ console.error(e); status('Error: '+e.message); }
  finally{ scanning=false; schedule(); }
}
function grabFrame(){ frame.width=video.videoWidth; frame.height=video.videoHeight; fctx.drawImage(video,0,0,frame.width,frame.height); return frame; }

/* ====== Scryfall ====== */
async function fetchBySetAndNumber(set, number, lang){
  try{ const langPart=(lang && lang.toLowerCase()==='sp')?'/es':''; const url=`https://api.scryfall.com/cards/${set.toLowerCase()}/${encodeURIComponent(number)}${langPart}`;
       const r=await fetch(url); if(r.ok){ const j=await r.json(); return [j]; } }catch(e){}
  return [];
}
async function scry(url){ try{ const r=await fetch(url); const j=await r.json(); return j.data||[]; }catch(e){ return []; } }
async function lookupPrice({code, setInfo, preferEs}){
  let data=[]; if(setInfo?.set) data=await fetchBySetAndNumber(setInfo.set, code.number, setInfo.lang);
  if(!data.length){
    let q=`number:${code.number}`+(setInfo?.set?` set:${setInfo.set.toLowerCase()}`:'')+(preferEs?' lang:es':'')+(code.rarity?` rarity:${code.rarity.toLowerCase()}`:'');
    const url=`https://api.scryfall.com/cards/search?q=${encodeURIComponent(q)}&unique=prints&include_extras=false&order=eur&dir=desc`;
    data=await scry(url);
  }
  if(!data.length) return {ok:false, why:'Sense resultats.'};
  const items=data.map(c=>{ const p=c.prices||{}; const eur=+(p.eur||p.eur_foil||0); const usd=+(p.usd||p.usd_foil||p.usd_etched||0); return {card:c,eur,usd,best:(eur||usd||0)}; }).sort((a,b)=>b.best-a.best);
  const b=items[0];
  return { ok:true, name:b.card.name, set:b.card.set.toUpperCase(), lang:b.card.lang.toUpperCase(), number:b.card.collector_number, rarity:b.card.rarity, eur:b.eur||null, usd:b.usd||null, link:b.card.scryfall_uri||b.card.uri };
}

/* ====== UI ====== */
function renderPrice(res){
  if(!res.ok){ lastPrice.textContent='‚Äî'; explain.textContent=res.why||'‚Äî'; return; }
  lastSet.textContent=`${res.set} ‚Ä¢ ${res.lang}`;
  lastPrice.innerHTML=`${res.eur?res.eur.toFixed(2)+' ‚Ç¨':'‚Äî'} <span class="muted">(USD ${res.usd?res.usd.toFixed(2):'‚Äî'})</span>`;
  explain.innerHTML=`${res.name} ¬∑ #${res.number} ¬∑ ${res.rarity} ¬∑ <a href="${res.link}" target="_blank" rel="noopener">Scryfall</a>`;
  const row=document.createElement('div'); row.className='item';
  row.innerHTML=`<div><b>${res.name}</b> (${res.set}) ¬∑ #${res.number} ¬∑ ${res.lang}</div>
                 <div>Preu: <b>${res.eur?res.eur.toFixed(2)+' ‚Ç¨':'‚Äî'}</b> <span class="muted">(USD ${res.usd?res.usd.toFixed(2):'‚Äî'})</span></div>`;
  listEl.prepend(row);
  const thr=Number(thresholdIn.value)||0; if((res.eur||res.usd||0)>=thr) beep();
}
function beep(){ if(!beepChk.checked) return; const ctx=new (window.AudioContext||window.webkitAudioContext)(); const o=ctx.createOscillator(); const g=ctx.createGain(); o.frequency.value=920; o.connect(g); g.connect(ctx.destination);
  g.gain.setValueAtTime(0.0001, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.45, ctx.currentTime+0.01); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.25); o.start(); o.stop(ctx.currentTime+0.26); }

/* ====== Controls ====== */
startBtn.onclick = async()=>{ await startCam(); };
stopBtn.onclick  = stopCam;
flipBtn.onclick  = async()=>{ facing=(facing==='environment'?'user':'environment'); stopCam(); await sleep(150); startCam(); };
pauseChk.onchange = e=>{ paused=e.target.checked; };
zoomInput.oninput = e=>{ const v=Number(e.target.value); if(track?.applyConstraints){ track.applyConstraints({advanced:[{zoom:v}]}); } };
editRoiBtn.onclick = ()=>{ editing=!editing; editTarget=(editTarget==='code'?'set':'code'); roiWhich.textContent=(editTarget==='code'?'Codi':'Set'); };
/* tocar v√≠deo ‚Üí pausa; doble-tap ‚Üí obre/plega debug */
let lastTap=0; stage.addEventListener('click',()=>{ const now=Date.now(); if(now-lastTap<300){ dbgDetails.open=!dbgDetails.open; } else { paused=!paused; pauseChk.checked=paused; } lastTap=now; });

/* arrossegar ROI seleccionat */
ovl.addEventListener('touchstart',e=>{
  if(!editing) return; const t=e.touches[0]; const r=ovl.getBoundingClientRect(); const x=(t.clientX-r.left)/r.width, y=(t.clientY-r.top)/r.height;
  window._drag={start:{x,y}, base:{...ROI[editTarget]}};
},{passive:true});
ovl.addEventListener('touchmove',e=>{
  if(!editing || !window._drag) return; const t=e.touches[0]; const r=ovl.getBoundingClientRect(); const x=(t.clientX-r.left)/r.width, y=(t.clientY-r.top)/r.height;
  const dx=x-window._drag.start.x, dy=y-window._drag.start.y;
  ROI[editTarget].x=Math.max(0,Math.min(1-ROI[editTarget].w, window._drag.base.x+dx));
  ROI[editTarget].y=Math.max(0,Math.min(1-ROI[editTarget].h, window._drag.base.y+dy));
  drawOverlay('editant ROI');
},{passive:false});
ovl.addEventListener('touchend',()=>{ window._drag=null; });

/* overlay sempre a mida del v√≠deo */
new ResizeObserver(()=>drawOverlay()).observe(stage);

/* planificador */
function schedule(){ if(!running) return; const ms=Math.max(250, Number(intervalIn.value)*1000); timer=setTimeout(tick, ms); }
function grabFrame(){ frame.width=video.videoWidth; frame.height=video.videoHeight; fctx.drawImage(video,0,0,frame.width,frame.height); return frame; }
</script>
</body>
</html>
